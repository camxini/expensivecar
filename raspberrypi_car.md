# Phase 1 SRTP部分

Time: 2024.4-2025.5

## 1. 硬件配置

### 1.1 用到的硬件

- 树莓派Raspberry Pi 4B 4GB
- 思岚激光雷达RPLIDAR A1
- L298N电机驱动模块
- MC520编码器电机
- 一个12V串联电池盒
- 面包板
- 两轮+万向轮的底盘
- 21英寸显示屏

### 1.2 买了但是没用到的硬件

- TB6612 FNG电机驱动板模块
- Arduino UNO板
- HC-SR04超声波测距模块
- LM2596S稳压模块
- N20减速马达
- 7寸显示屏
- 角码
- 电烙铁
- AB胶

## 2. 硬件组装过程

### 2.1 树莓派RPIO接口说明

[树莓派接口](https://shumeipai.nxez.com/raspberry-pi-pins-version-40)

上面的文章介绍了树莓派的GPIO引脚对照表，调用引脚的时候用python的RPi.GPIO库，设置模式为BCM，然后调用物理引脚对应的BCM编码。

e.g. 如果要调用物理引脚16，需要：

```python
import RPi.GPIO as GPIO
GPIO.setmode(GPIO.BCM)
example = 23 # 23是物理引脚16对应的BCM编码
```

这是一种简单的定义一个引脚example的方式，它的物理引脚号是16，BCM引脚号是23.

然后再加上这个：

```python
GPIO.setup(21, GPIO.INPUT)
GPIO.setup(23, GPIO.OUTPUT)
``` 
就把引脚作为GPIO输入或者输出了。

**关于GPIO引脚是否支持中断：** 所有的有BCM编号的GPIO引脚都支持中断，这和Arduino有很大区别。

### 2.2 关于编码器电机

编码器电机和普通的电机不太一样，可以简单理解为普通电机给电压或者PWM信号就可以转，编码器电机给了电压或者PWM信号转了以后，会返回值给控制器。也就是说，普通电机是开环控制的，编码器电机可以实现闭环控制。

利用编码器电机的闭环控制特点就可以实现PID转速调节。

#### 2.2.1 编码器电机接线说明

如果我没记错的话，我的电机是这样接的（不同编码器电机不太一样，可以参考电机的技术文档）：

```txt
1 -- 电机电源线-    接12V电池组的负极
2 -- 编码器电源VCC  接树莓派GPIO的5V
3 -- 编码器信号A相  
4 -- 编码器信号B相  
5 -- 编码器地线GND  接树莓派GPIO的GND
6 -- 电机电源线+    接12V电池组的正极
```

A相是输出正交脉冲信号的，B相和A相相位差差了90度，差的相位可以判断旋转方向。

总之，就把A相和B相理解成电机反馈给控制器的信号就行。

#### 2.2.2 编码器电机的转速计算

我的编码器电机输入的是PWM信号，但是实际上我们要控制的是电机的转速rpm，它们之间的转换关系是：

$$
w_{rpm} = f_{pwm} / (n * PPR) * 60
$$

其中，PPR是电机每转脉冲数，在电机的技术文档里会提到。

n表示的是采用的是n倍频，就是信号里不同频率成分相对于基频的倍数关系。通常信号分析的时候会有一个图谱，显示哪个频率的信号出现次数是峰值，那个就是基频，然后会有基频的倍数频率出现小一点的峰值，这就是几倍频。这个通常用在故障分析和信号排查里面，在电机这里这个东西没那么重要，n设成几都行，我用的是四倍频。

这样就建立了PWM频率和转速rpm之间的关系。

#### 2.2.3 编码器电机的PID转速控制

利用python的simple_pid库可以实现转速调节，以一个电机为例，代码如下：

add code here

#### 2.2.4 通过键盘控制点击运动

add code here

### 2.3 激光雷达

我用的是RPLIDAR A1, 这是一个2D的激光雷达，所以slam建图建出的结果也只能是2D平面的图，或者你可以理解为和做CT一样在一个特定平面扫描出来的结果。这个是有很大弊端的，因为对于一些在不同高度形状不同的障碍物，可能识别会有问题，在地面不平的时候更是会出现大问题（但没办法，没钱买更好的激光雷达了，我还想买个深度相机呢，奈何是真的没钱）。

如果有人资金充裕的话，可以考虑从3D的雷达，这样也可以省下买深度相机的钱。

拿到激光雷达之后，他会自带一个芯片，按照激光雷达的技术手册把芯片连接好，然后直接连到树莓派上就可以。这个是用c口连接的，不需要考虑GPIO的接口。连上以后激光雷达就会开始转，其实就是已经开始运行了。

### 2.4 电机驱动模块

用的是L298N的电机驱动模块，当然你也可以用TB6612等电机驱动模块。我用L298N是因为L298N我之前用过，比较熟练，但是L298N有一个大大的散热片，电机如果运转时间很长的话，有可能会烫到手（或者烫到导线）。

#### 2.4.1 L298N的接线方式

[L298N](https://blog.csdn.net/GuanFuXinCSDN/article/details/104158512)

上面的文章介绍了L298N的具体内容，按照文章里的方法1来接线。具体接线是这样的：

```text
IN1 - 电机1电源线+
IN2 - 电机1电源线-
IN3 - 电机2电源线+
IN4 - 电机2电源线-
12V - 12V电池正极
GND - 12V电池负极和树莓派GND引脚
5V - 树莓派5V引脚
```

#### 2.4.2 为什么要用电机驱动模块而不是直接连接电机？

如果电源直接连接电机，那么电机接收到的就是一个固定的电压和电流，电机只能以一个恒定的速度和恒定的方向转动。电机驱动模块可以控制输出的电压电流，从而控制电机的转速。

另外，如果电源直接连接电机的话，电源提供的电流(<50mA)不足以直接驱动电机，驱动模块有放大电流的电路。

### 2.5 超声波模块

#### 2.5.1 代码实现
HC-SR04是最经典的超声波测距模块了，网上有很成熟的教程：[HC-SR04](https://blog.csdn.net/ling3ye/article/details/51407328)

当然这个教程是连接Arduino的，里面的代码也是arduino语言，这个需要换成在树莓派里可以运行的python代码：

```python
TRIG = 23
ECHO = 24 #初始化引脚，取决于你把超声波的trig和echo接在了哪个引脚上

GPIO.setup(TRIG, GPIO.OUT)
GPIO.setup(ECHO, GPIO.IN)

while(1)
{
  GPIO.output(TRIG, True)
  time.sleep(0.00001)
  GPIO.output(TRIG, False)
  start_time = time.time()
  stop_time = time.time()
  while GPIO.input(ECHO) == 0:
    start_time = time.time()
  while GPIO.input(ECHO) == 1:
    stop_time = time.time()
  delta_time = stop_time - start_time
  distance = (delta_time * 34000） / 2 # 声速340m/s
}
```

这个代码的逻辑很明确，就是发送记一个时间，接收记一个时间，然后用声速计算距离，输出的distance就是测量到的距离。

#### 2.5.2 超声波测距的原理

这个传感器有两个大筒，一个是发射超声波的，一个是接收超声波的，用很经典的 $v=s/t$ 就能测出来距离。

但也有很明显的缺点，他只能测正前方以及最多15度的范围，如果说要进行侧面避障和后面避障，要么用其他的传感器，要么安一圈HC-SR04。

（为什么有这个缺点还要用呢？因为简单还便宜。）

### 2.6 关于显示屏

一开始我是买了个7寸的显示屏，想着就简单显示一个ubuntu的桌面就可以了。但是rviz（如果你不知道的话，你先理解为一个电脑上的应用）要显示的东西比较多，7寸的显示屏分辨率太小，放不下屏幕上的所有信息，还得疯狂的拖动窗口才能看到一部分。

最后我就换了一个21寸的显示器，这个确实显示效果不错，现在还在我的桌子上当电脑的显示器。

### 2.7 整个AGV的硬件连接

#### 2.7.1 GPIO接口

add code here

#### 2.7.2 其他线路连接

- RPLIDAR A1的芯片直接通过C口连接到树莓派上面；
- 显示器的线路是HDMI-micro HDMI转接线，其中HDMI端接显示器，micro HDMI端接树莓派。
- 键盘和鼠标要用USB的，直接接在树莓派上，蓝牙的不行。
- 树莓派直接接220V电源，同时显示器也要接220V电源。显示器的电源线**不要接树莓派**，因为电压不够。

**注意：** micro HDMI的头长的非常像A口，但是实际上不一样，A口插不进去树莓派。
